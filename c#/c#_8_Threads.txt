Process
	- Process is to facilitate the execution of a program. Each process has a unique process Id associated with it. 
	- Thread is a light weight process. A process has at least one thread (main thread) which actually executes 
	  the application code. A single process can have multiple threads.

Advantages of multithreading:
	1. To maintain a responsive user interface
	2. To make efficient use of processor time while waiting for I/O operations to complete.
	3. To split large, CPU-bound tasks to be processed simultaneously on a machine that has multiple CPUs/cores. 

Disadvantages of multithreading:
	1. On a single-core/processor machine threading can affect performance negatively as there is overhead involved with context-switching.
	2. Have to write more lines of code to accomplish the same task.
	3. Multithreaded applications are difficult to write, understand, debug and maintain.

Threading
---------
	- run the program paralley
	- excute program in a multi thread  or parallel way.
	- 2 kinds of thread - foreground and background thread
	- foreground threads are thread which will keep running even though if your main application exists or quits.
	- background threads are thread which will quit if your main applicaiton quit, 
	  means until your main application is alive the background
	- 3 thread synchronizaton technique - Lock (or Monitor), Mutex, Semaphore 	  
	- simple thread safe use Lock.

	- foreground threads examples
	--------------------------
	using System.Threading;
	public void main()
	{
	    //executing sequentially
	    //Print1(); 
	    //Print2(); //Print 1 0 ...Print 2 0... Print 2 9

	    //foreground thread example
	    //creating thread
	    Thread t1 = new Thread(Print1);
	    Thread t2 = new Thread(Print2);
	    //invoke the thread
	    t1.Start();
	    t2.Start();
	    //application quits here
	    Debug.WriteLine("End");
	    /*output End Print 1 0 Print 2 0 Print 2 1 Print 2 2 Print 2 3  Print 1 1 Print 1 2..*/
	}

	static void Print1()
	{
	    for (int i=0;i<10;i++)
	    Debug.WriteLine("Print 1 "  + i);
	    //wait for 5 seconds
	    Thread.Sleep(5);
	}

	static void Print2()
	{
	    for (int i = 0; i < 10; i++)
		Debug.WriteLine("Print 2 " + i);
	    //wait for 5 seconds
	    Thread.Sleep(5);
	}
	
	example 2
	---------
	static void Main(string[] args)			
	{						
	    Console.WriteLine("Start");
	    Thread t1 = new Thread(Print);
	    t1.Start();
	    Console.WriteLine("End ");
	    Console.ReadLine();
	}

	static void Print()
	{
	    Console.WriteLine("Print Start");
	    Thread.5leep(5000);
	    Console.WriteLine("Print End");
	}
	output
	------
	Start
	End
	Print Start
	asdsa, [if i enter something, console won't close wait to finish Print(), then next line print]
	Print 1 End

	example 3 - background
	----------------------------
	using System.Threading;
	static void Main(string[] args)
	{
	    Console.WriteLine("Start");
	    Thread t1 = new Thread(Print);
	    t1.IsBackground = true;
	    t1.Start();
	    Console.WriteLine("End ");
	    Console.ReadLine();
	}

	static void Print1()
	{
	    Console.WriteLine("Print Start");
	    Thread.5leep(5000);
	    Console.WriteLine("Print End");
	}
	output
	------
	Start
	End
	Print Start
	asdsa [if i enter something, console will close immediately, it won't wait for to finish Print()]
	Print 1 End [i can't see this line, it will run background]

	- multithreading and thread safe objects -Lock or monitor
	----------------------------------------
	class MathClass
	{
		public int i;
		public int j;
		Random r = new Random();
		public void Divide()
		{
		    //mutlitherad is happing here.
		    for (int x = 0; x < 10000; x++)
		    {
		    	//what even statments(scope) inside the lock , only one thread can executed.
		    	//lock(this) 
		    	//{
				i = r.Next(1, 2);
				j = r.Next(1, 2);
				double d = i / j;
				i = 0;
				j = 0;
			//}
			or
			Monitor.Enter(this)
			i = r.Next(1, 2);
			j = r.Next(1, 2);
			double d = i / j;
			i = 0;
			j = 0;
			Monitor.Exit(this)
			
			OR 
			try  
			{  
			   Monitor.Enter(x);  
			    try  
			    {  
			        // Code that needs to be protected by the monitor.  
			    }  
			    finally  
			    {  
			          
			       Monitor.Exit(x);  
			    }  
			}  
			catch (SynchronizationLockException e)  
			{  
			    
			}  
		    }
		}
	}

	public class ThreadClass
	{
		//if you want call the non static method inside the static method, add static infront the object.
		static MathClass mc = new MathClass();
		[TestMethod]
		public void main()
		{
		    Thread t = new Thread(mc.Divide);
		    t.Start(); //child thread
		    mc.Divide(); //main thread
		}
	}	
	"Attempted to divide by zero" error message will be throw.
	Bcaz our MathClass is not thread safe, why the error is comming?
	Both of thread are calling this divide function in a concurrent manner, it is possible main thread is dividing and 
	child thread is setting the j value is zero. so you get the exception.
	
	Solution is, inside the for loop code, at least one time only one thread should execute. 
	To avoid this situation, using proper thread synchronization, use Lock Lock(this) {} or Monitor.
	

Interlocked & compare Lock (Protecting shared resources from concurrent access in multithreading)
----------------------------------------------------------------------------------------------
class Program
{
static int total = 0;
static object obj = new object();
static void Main(string[] args)
{
    Stopwatch sw = new Stopwatch();
    sw.Start();
    //it prints always 3000000, ElapsedTicks - 20126, 20513, 23702
    /*Print();
    Print();
    Print();*/

    Thread t1 = new Thread(Print);
    t1.Start();
    Thread t2 = new Thread(Print);
    t2.Start();
    Thread t3 = new Thread(Print);
    t3.Start();

    t1.Join();
    t2.Join();
    t3.Join();

    sw.Stop();
    Console.WriteLine(total + "  " + sw.ElapsedTicks);
    Console.ReadLine();
}

static void Print()
{
    //1st time it prints 1418264, 2nd time 2107290, 3rd time 2180137
    //so it is inconisitent for every times
    /*for (int i = 0; i < 1000000; i++) total++;*/

    // 2 options Protecting shared resources from concurrent access in multithreading
    
    //option 1 using Interlocked, ElapsedTicks - 252664, 203408, 182927, it is fast compar to lock
    /*for (int i = 0; i < 1000000; i++) Interlocked.Increment(ref total);*/

    //option 2 using lock, ElapsedTicks - 349149, 396371, 264351, it slow performance
    for (int i = 0; i < 1000000; i++)
    {
	lock (obj)
	{
	    total++;
	}
    }
}

Interlocked.Increment() is fase compare to lock() {} (slow performance).


Deadlock in a multithreaded program
---------------------------------------------------------------------------
Thread1 \ 			       		/Thread2
|	 \(Thread1 wants locked Resource2)      / |
|locked	  \			     		/ |locked 
|(Thread1  \locked Resource1)	    		/ |(Thread2 locked Resource2)
V	    \--------------------------------->	/ V	
Resource1<------------------------------------- /Resource2
	  (Thread2 wants locked Resource1)
	          X

When a deadlock can occur, let's say 2 threads (Thread1, Thread2) and 2 Resouces( Resouce1, Resource2).
Thread 1 has already acquired a lock on Resource1 and wants to acquire a lock on Resource 2. 
At the same time  Thread 2 has already acquired a lock on Resource2 and wants to acquire a lock on Resource 1.

2 Threads never give up their locks, hence a deadlock occured

Deadlock exmple

using System.Diagnostics;
namespace ConApp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Start");
            Account a = new Account(101, 5000);
            Account b = new Account(102, 7000);

            AccountManager am1 = new AccountManager(a, b, 2000);
            Thread t1 = new Thread(am1.Transfer);
            t1.Name = "T1";
            t1.Start();

            AccountManager am2 = new AccountManager(b, a, 3000);
            Thread t2 = new Thread(am2.Transfer);
            t2.Name = "T2";
            t2.Start();

            t1.Join();
            t2.Join();

            Console.WriteLine("End");

            Console.ReadLine();
        }
    
    }

    class AccountManager
    {
        public Account _fromAccount {set; get;}
        public Account _toAccount { set; get; }
        public double _amount { set; get; }

        public AccountManager(Account a , Account b, double d)
        {
            this._fromAccount = a;
            this._toAccount = b;
            this._amount = d;
        }

        public void Transfer()
        {
            Console.WriteLine(Thread.CurrentThread.Name + " trying to acquire lock on " + _fromAccount.id.ToString());
            lock (_fromAccount)
            {
                Console.WriteLine(Thread.CurrentThread.Name + " acquired lock on " + _fromAccount.id.ToString());
                Console.WriteLine(Thread.CurrentThread.Name+ " suspended for 1 second");
                Thread.Sleep(1000);
                Console.WriteLine(Thread.CurrentThread.Name + " back in action and trying to acquire lock on " + _toAccount.id.ToString());
                lock (_toAccount)
                {
                    Console.WriteLine("Deadlock = Not Reached Here");
                    _fromAccount.Withdraw(_amount);
                    _toAccount.Deposit(_amount);
                }
            }
        }
    }

    class Account
    {
        public int id { set; get; }
        public double amount { set; get; }

        public Account(int id, double amount)
        {
            this.id = id;
            this.amount = amount;
        }

        public void Deposit(double amount)
        {
            this.amount += amount;
        }

        public void Withdraw(double amount)
        {
            this.amount -= amount;
        }
    }
}

output
------
Start
T1 trying to acquire lock on 101
T1 acquired lock on 101
T1 suspended for 1 second
T2 trying to acquire lock on 102
T2 acquired lock on 102
T2 suspended for 1 second
T1 back in action and trying to acquire lock on 102
T2 back in action and trying to acquire lock on 101

not reached this code => "Deadlock = Not Reached Here"


Resolving Deadlocks
-------------------
These are several techniques to avoid and resolve deadlocks
1)Acquiring locks in a specified defined order
2)Mutext class
3)Monitor.TryEnter() method.


1)Acquiring locks in a specified defined order , the above Transnsfer function is re arranged
-----------------------------------------------

public void Transfer()
{
    object _a;
    object _b;
    if (_fromAccount.id < _toAccount.id)
    {
	_a = _fromAccount;
	_b = _toAccount;
    }
    else
    {
	_b = _fromAccount;
	_a = _toAccount;
    }

    Console.WriteLine(Thread.CurrentThread.Name + " trying to acquire lock on " + ((Account)_a).id.ToString());
    lock (_a)
    {
	Console.WriteLine(Thread.CurrentThread.Name + " acquired lock on " + ((Account)_a).id.ToString());
	Console.WriteLine(Thread.CurrentThread.Name+ " suspended for 1 second");
	Thread.Sleep(1000);
	Console.WriteLine(Thread.CurrentThread.Name + " back in action and trying to acquire lock on " + ((Account)_b).id.ToString());
	lock (_b)
	{
	    Console.WriteLine(Thread.CurrentThread.Name + " acquired lock on "+ ((Account)_b).id.ToString());
	    _fromAccount.Withdraw(_amount);
	    _toAccount.Deposit(_amount);

	     Console.WriteLine(Thread.CurrentThread.Name + " Transfered " + _amount.ToString() + " from "
		+ _fromAccount.id.ToString() + " to " + _toAccount.id.ToString());
	}
    }
}

Start
T1 trying to acquire lock on 101
T1 acquired lock on 101
T1 suspended for 1 second
T2 trying to acquire lock on 101
T1 back in action and trying to acquire lock on 102
T1 acquired lock on 102
T1 Transfered 2000 from 101 to 102
T2 acquired lock on 101
T2 suspended for 1 second
T2 back in action and trying to acquire lock on 102
T2 acquired lock on 102
T2 Transfered 3000 from 102 to 101
End

Performance of a multithreaded program
---------------------------------------
	- The performance implications of multi-threaded program and run on a single core processor
	  machine versus multi-core processing machine 
	- Find out how many processors
		-Task manager -> Performance -> See number CPU
		-C# Console.WriteLine(Environment.ProcessorCount);
		-cmd, type echo %NUMBER_OF_PROCESSORS%
		
	- on a machine that has multiple processors, multiple threads can execute application code in parallel 
	  simultaneously on different cores
	  for example if there are 2 threads and 2 cores, then each thread would run on an individual core,  performance is better
	  if 2 threads take 10 milliseconds each to complete, then on a machine with 2 processors, a total time taken is 10 milliseconds.
	  
	- on a machine that has a 1(single) processor, multiple threads execute, one after the other or wait until one thread finishes.
	  it's not possible for a single processor system to execute multiple threats in parallel. since the os switches between 
	  these threads so fast, it just gives us the illusion that threads are running in parallel. but affect performance negatively
	  if 2 threads take 10 milli-seconds each to complete, then on a machine with 1 processor, 
	  the total time taken is 20 milli-seconds+ (Thread context switching time, if any)

	- i have 4 processors
static void Main(string[] args)
        {
            Console.WriteLine("Start");
            Stopwatch sw = new Stopwatch();
            sw.Start();
            SumOdd();
            SumEven();
            SumOdd();
            SumEven();
            sw.Stop();
            Console.WriteLine("Without MT " + sw.ElapsedTicks);

            sw = new Stopwatch();
            sw.Start();
            Thread t1 = new Thread(SumOdd);
            t1.Start();
            Thread t2 = new Thread(SumEven);
            t2.Start();
            Thread t3 = new Thread(SumOdd);
            t3.Start();
            Thread t4 = new Thread(SumEven);
            t4.Start();
            t1.Join();
            t2.Join();
            t3.Join();
            t4.Join();
            
            Console.WriteLine("With MT " + sw.ElapsedTicks);
            Console.WriteLine("End");
            Console.ReadLine();
        }

        static void SumOdd()
        {
            int s=0;
            for(int i=0;i<5000000;i++) {
                if (i % 1 == 0) s += i;
            }
            Console.WriteLine(s);
        }

        static void SumEven()
        {
            int s = 0;
            for (int i = 0; i < 5000000; i++)
            {
                if (i % 2 == 0) s += i;
            }
            Console.WriteLine(s);
        }
Output
------
Start
1642668640
820084320
1642668640
820084320
Without MT 219430 [slow performance all are running on same processor]
820084320
820084320
1642668640
1642668640
With MT 107179 [fast performance each thread is running on one processor]
End
        

What is TPL(Task Parallel Library) and How it differs from threads?
---------------------------------------------------------------------
	- TPL encapsulates mulit-core execution
	- run logic parallel, our expectation is that this RunMillionIterations shoul utilize the CPU power to the maximum
	- so for example, you have a P2 or P4 machine, then my exceptions would be to make this rally Multi threaded, 
	  1/2 of the Million record should execute on core 1 and 1/2 of the Million records logic should execute on Core 2 
	  and then finally all the data should be concatenated inside this X
	  
	  for (Loop)	   ---1/2 million runs here/Core1->|s	
	  {		   |			  	   |y   update
	   million times   |                               |n ---------> Variable[x] 
	  }		   ---1/2 million runs here/Core2->|ch	
	  
	-i would like that it should actually utilize my complete hardware power of my computer,but in reality these is not happen, 
	-in other words when i invoke this RunMillionIterations inside this thread, it actually runs just only one processor.

	Using performance monitor tool (demonstrate how the thread runs utilized only one core)
	-----------------
	- which help you to monitor different aspect of your computer like processor, Memory
	- Open Run, enter 'perfmon', 
	- currently we are interested that our application how does it utilize all the four processors
	- from Show list, right click & remove all the default counters
	- click add counters->available counters -> scroll down select 'Processor' -> select '% Processor Time' ->
	  from 'Instance of selected object' -> Add 0,1,2,3, (each of this represent each of a processor)
	- which are important from the processor prescriptive currently we are interested to know that 
	- how much our processor time is been utilize
	- select the properites -> change width to thick line
	
	using System.Threading;
	namespace ConApp
	{
	    class Program
	    {
	        static void Main(string[] args)
	        {
	            Thread t = new Thread(RunMillionIterations);
	            t.Start();
	            Console.Read();
	        }
	
	        static void RunMillionIterations()
	        {
	            string x ="";
	            for (int i = 0; i < 1000000; i++)
	            {
	                x=x+'s';
	            }
	        }
	    }
	
	}

	- run the code, clear performance monitor, start monitoring what it is doing now you can see clearly
	- over here all the processor are not getting optimally utilize, processor 1 (red sign), it is being leased utilized
	- or all three processor are the least utilized and processor 3(P3 or core 3) has been utilized to the maximum
	- in other words that is getting loaded more than any other processor
	- so it is not happening here, all the processor not be optimally utilize.
	- we are doing threading, we are actually not doing threading or parallel execution but we are doing time slicing.
	- time slicing
	  ------------
	  - for example, start with thread 1 and that time it will not start thread 2, it will gives times to thread1 
	  - & it will execute some logic of thread1 after that he will make a switch to thread2 and
	  - that it will start executing thread2 and tha time thread 1 will not start
	  - the processor actually switches or distributes time between those thread and 
	  - it keeps switching from thread 1 to thread 2, thread 2 to thread 1, so
	  - in other words actually multi threading is not happening, time slicing is happening 
	  - if the processor is going to switch time between thread 1 and thread 2, it will decreasing performance instead
	  - of incresing performance
	  
	  Single Processor
	  Thred1	Thread2
	  |
	  |
	  Switch to	|
	  Thread2	|
	  		|
	  |		Switch to
	  |		Thread1
	  |
	  
	- i want thread 1 to execute on processor 1 and thread 2 to execute on processor 2, to achieve parallelism,
	- our logic should get executed optimally on all the processors
	-  TPL will smartly execute those logic on the processors
	  Processor1	Processor2
	  Thred1	Thread2
	  |		|
	  |		|
	  |		|
	  
	-for TPL use namespace system.threading.Tasks & parallel keywords
	using System.Threading;
	using System.Threading.Tasks;
	namespace ConApp
	{
	    class Program
	    {
		static void Main(string[] args)
		{
		    Parallel.For(0, 1000000, x=>RunMillionIterations());
		    Console.Read();
		}

		static void RunMillionIterations()
		{
		    string x ="";
		    for (int i = 0; i < 1000000; i++)
		    {
			x=x+'s';
		    }
		}
	    }
	}	
	- for example, 2 core machine then it should probably run 1/2 million loops on core 1 and 1/2 the million loops on core 2
	- so it optimal utilization of my processors of my machine
	- run the code, clear performance monitor, start monitoring what it is doing now you can see clearly
	- all the cores are getting optimally utilize


Cross Thread prevention techniques
----------------------------------
	-if (frm2.txtReceive.InvokeRequired) {
	 	frm2.txtReceive.Invoke((MethodInvoker)delegate(){})}; - this mehtod preventing cross thread.
	- if the above is missing, just frm2.txtReceive.Text = s;, system will throw the message.
		Cross-thread operation not valid: Control 'txtReceive' accessed from a thread other than the 
		thread it was created on.
	-Add Form (Form1), add TextBox (txtSend) & Close (btnClose) button.
	-Add Form (From2), add TextBox (txtReceive), change modifiers to public
	Form1.cs
	-------
	using System.Threading;
	namespace ConApp
	{
	    public partial class Form1 : Form
	    {
	        Form2 frm2 = new Form2();
	        public Form1()
	        {
	            InitializeComponent();
	            Thread t = new Thread(new ThreadStart(ShowForm2));
	            t.Start();
	        }
	
	        private void ShowForm2()
	        {
	            Application.Run(frm2);
	        }
	
	        /*private void btnSend_Click(object sender, EventArgs e)
	        {
	            SendTexttoForm2(txtSend.Text);
	        }*/
	
	        private void SendTexttoForm2(string s)
	        {
	            if (frm2.txtReceive.InvokeRequired)
	            {
	                frm2.txtReceive.Invoke((MethodInvoker)delegate()
	                {
	                    SendTexttoForm2(s);
	                });
	            }
	            else frm2.txtReceive.Text = s;
	        }
	
	        private void btnClose_Click(object sender, EventArgs e)
	        {
	            CloseForm2();
	        }
	
	        private void CloseForm2()
	        {
	           if (frm2.txtReceive.InvokeRequired)
	            {
	                frm2.txtReceive.Invoke((MethodInvoker)delegate()
	                {
	                    CloseForm2();
	                });
	            }
	            else frm2.Close();
	        }
	
	        private void txtSend_TextChanged(object sender, EventArgs e)
	        {
	            SendTexttoForm2(txtSend.Text);
	        }
	
	    }
	}
	Program.cs
	-------
	using System.Windows.Forms;
	
	namespace ConApp
	{
	    class Program
	    {
	        static void Main(string[] args)
	        {
	            Application.Run(new Form1());
	        }
	    }
	}
	-run the project, both form1 and form2 will be visible, ente form1 textbox, text change will be appear on the form2.
	-click the close button, it will close the form2, if you enter form1 textbox,the application will still work without form2.
	- /*if (frm2.txtReceive.InvokeRequired)
	    {
		frm2.txtReceive.Invoke((MethodInvoker)delegate()
		{
		    SendTexttoForm2(s);
		});
	    }
	    else*/ frm2.txtReceive.Text = s;	
	    the application wiil throw the error message.


What is AutoResetEvent and ManualResetEvent ?
----------------------------------------------
	- both methods help us to do syncronization by using the signaling methodology
	- what is the signaling methodolgy?
	- Thread 1		Thread 2
	   |			    |	
	   |     want to implement  |	
	   |-------->Synch<---------|	
	   |     between 2 threads  |
	   |			    |
	   |-------wait-----------> V
	   |			   ^	
	   |			   |	
	   V---------start---------| 		
	- 2 threads, want to implement syncronization between these two threads.
	- syncronization is, thread 1 is send a signal out to thread 2, pls wait or hold here, 
	- and than thread 1 can continue doing is work and when thread 2 finishes, it send signal again to thread 1, 
	- start from the place where you have holded.
	- so in this way by using the signalling methodology we can implement synchronization between thread
	
	- AutoResetEvent 
	----------------
	void main()
	|
	|-----------------------
	|			|
	|main thread 1		|new thread 2
	|			|
	|			Wait()
	set()-----signals------>|
	|			|
	|			|Thread continues
	|			|
	|			Finish
	Finish			

	- to better understand auto reset event, call this waitone() two times
	- run the application, the first waitone so i do enter you can see now the first waitone is released 
	- now there is a second waitone if i do enter here now the second waitone is released
	- so for every waitone we should have a one set which will actually go and release that waitone.
	
	using System.Threading.Tasks;
	using System.Threading;
	namespace ConApp
	{
	    class Program
	    {
	        static AutoResetEvent are = new AutoResetEvent(false);
	        static void Main(string[] args)
	        {
	            new Thread(Display).Start(); //it will invoke some method in a different thread
	            Console.ReadLine();
	            //signaled to start again first time
	            are.Set(); //waitone at 1
	            Console.ReadLine();
	            //signaled to start again 2nd time
	            are.Set(); //waitone at 2
	            Console.ReadLine();
	        }
	
	        static void Display()
	        {
	            Console.WriteLine("Starting 1..");
	            //wait first time
	            are.WaitOne();
	            Console.WriteLine("Finishing 1..");
	            Console.WriteLine("Starting 2..");
	            //wait 2nd time
	            are.WaitOne();
	            Console.WriteLine("Finishing 2..");
	        }
	    }
	}
	output
	------
	Starting 1..
	[waiting here], enter the key,
	Finishing 2..
	Starting 2..
	[waiting here], enter the key,
	Finishing 2..
	
	- ManualResetEvent 
	----------------
	-sysntax is same just replace auto to manual
	-run the application, 'Starting 1..', [waiting here], enter the key, and revoked all the waitone 
	- means it clears or reset all the waitone()

	namespace ConApp
	{
	    class Program
	    {
	        static ManualResetEvent are = new ManualResetEvent(false);
	        static void Main(string[] args)
	        {
	            new Thread(Display).Start(); //it will invoke some method in a different thread
	            Console.ReadLine();
	            //signaled to start again first time
	            are.Set(); //waitone at 1
	            Console.ReadLine();
	            //signaled to start again 2nd time
	            are.Set(); //waitone at 2
	            Console.ReadLine();
	        }
	
	        static void Display()
	        {
	            Console.WriteLine("Starting 1..");
	            //wait first time
	            are.WaitOne();
	            Console.WriteLine("Finishing 1..");
	            Console.WriteLine("Starting 2..");
	            //wait 2nd time
	            are.WaitOne();
	            Console.WriteLine("Finishing 2..");
	        }
	    }
	}

	output
	------
	Starting 1..
	[waiting here], enter the key,
	Finishing 2..
	Starting 2..
	Finishing 2..
	- visualise auto reset event is like a turnstile gate, the gate where only one person can entered one moment of time
	- while manual reset event like a ordinary gate where it is open every body get Russ in

What are Async and Await ( .NET 4.5 Interview question with answers)?
---------------------------------------------------------------------
	using System.Threading.Tasks;
	using System.Threading;
	using System.Windows.Forms;
	
	namespace ConApp
	{
	    class Program
	    {
	        static void Main(string[] args)
	        {
	            Display();
	            Console.WriteLine("Main Method");
	            Console.ReadLine();
	        }
	
	        static  void Display()
	        {
	            Task.Run(new Action(LongTask)); // invoking 'LongTask' in  a multi threaded way or parallel way
	            				    //	using the task parallel library
	            Console.WriteLine("Display Method"); //wait until the long task finishes
	        }
	
	        static void LongTask()
	        {
	            //long job, loading csv files data or TPL or threading
	            Console.WriteLine("Print Method");
	            Thread.Sleep(20000);
	        }
	    }
	}

	output
	------
	Display Method
	Main Method
	Print Method
		
	- async and await keywords are used to create asynchronous methods. The async keyword specifies that a 
	  method is an asynchronous method and the await keyword specifies a suspension point. 
	- Aynch and Await are Markers, which mark code positions from where the control should resume after a task(thread) completes
	- run the application, the above is not waiting for finishing LongTask() method ("Print Method"), 
	- it executed after thread lines("Display Method")
	- I want this code or this line should run after this 20 seconds has finished executing
	- How do we go about achieving that, 
		- One way is you write lengthy codes, use Thread.wait & Thread.sleep, 
		- then again write synchronization logic between method and long task
		- other way is, easy .NET 4.5 feature Asynch and a Await
	- You cannot use Await without Asynch


	static async void Display()
	{
	    await Task.Run(new Action(LongTask));
	    Console.WriteLine("Display Method"); //wait until the long task finishes
	}
	
	output
	------
	Print Method
	Main Method
	Display Method
	
	
	Example 2
	---------
	
	 private int LoadFile() {
	    int count=0;
	    using (StreamReader reader = new StreamReader(@"C:\Users\kadermxabq\Downloads\SoapUI-x64-5.2.1.exe"))
	    {
		string content = reader.ReadToEnd();
		count = content.Length;
		// Make the program look busy for 5 seconds
		Thread.Sleep(5000);
	    }
	    return count;
	}

	private async void button1_Click(object sender, EventArgs e)	{
	    //the application does not display  "Processing"
	    //the application is busy processing the file, it becomes unresponsive, cannot move or resize the form 
	    /*textBox1.Text = "Processing";
	    LoadFile(); 		
	    textBox1.Text = i.ToString();*/
	    
	    //async and await will solve the above problem, the form is responsive.
	    Task<int> t = new Task<int>(LoadFile);
	    t.Start();
	    textBox1.Text = "Processing";
	    int i = await t;
	    textBox1.Text = i.ToString();
        }

You may have a few questions at this point. 
1. Can't we achieve the same thing using a Thread. 
2. What is the difference between a Thread and a Task
3. When to use a Task over Thread and vice-versa 

Example using Thread
--------------------
private  void button1_Click(object sender, EventArgs e)
{
    int i = 0;
    Thread t = new Thread(() => { i = LoadFile(); });
    t.Start();
    textBox1.Text = "Processing";
    //t.join()
    textBox1.Text = i.ToString();
}
At this point the application does not work as expected. We have two problems with the above code.
1. We do not see the message, "Processing" at all, 2. It displays "0"

Why is this happening
The Main thread(i.e the UI thread) has created a worker thread which executes LoadFile() function. 
The worker thread takes at least 5 seconds to complete. In the mean time the Main thread continues executing the 
following 2 lines of code (textBox1.Text).

This is because, the UI thread executes the above 2 lines of code so fast that the second message overwrites the first message 
and at that speed it is impossible for a human eye to spot the overwriting.
	
How to solve the above two problems - un comment t.join code.
At this point the application work, but introduced a new problem. While the application is busy processning the file, 
the UI is blocked i.e we cannot move the form around or resize it.

why can't we move the code that updates the label control Text property into the worker thread as shown below. 
This is dangerous because, the thread that has created the control must modify the control. 
In our case the Main thread (i.e UI Thread) is the thread that has created the label control so only the Main thread should set 
it's Text property and not the worker thread. If you run the application it may or may not work as expected. 
If it is working, it is only working by blind luck. 
private  void button1_Click(object sender, EventArgs e)
{
    int i = 0;
    Thread t = new Thread(() => { 
    	i = LoadFile();
    	//this is dangerous
	textBox1.Text = i.ToString();
    });
    t.Start();
    textBox1.Text = "Processing";
}

The right way to achieve this is by using BeginInvoke() method as shown below. 
BeginInvoke() method asks the UI thread to set the Text property of the label control in a type safe manner.

private  void button1_Click(object sender, EventArgs e)
{
    int i = 0;
    Thread t = new Thread(() => { 
	i = LoadFile();
	Action a = () => { textBox1.Text = i.ToString(); };
	this.BeginInvoke(a);
    });
    t.Start();
    textBox1.Text = "Processing";
}

To re write the above code = > it is exactly replacement of Example 2 achiving using a Task, the below code is complicted
int i = 0;
private  void button1_Click(object sender, EventArgs e)
{
    Thread t = new Thread(() => { 
	i = LoadFile();
	Action a = new Action(Display);
	this.BeginInvoke(a);
    });
    t.Start();
    textBox1.Text = "Processing";
}

private void Display()
{
    textBox1.Text = i.ToString();
}
	
----------------------------------------------------------------------

ThreadStart/ParameterizedThreadStart Delegate
---------------------------------------------
	- the constructor (new Thread(...)) of the thread class there are four overloaded versions.
		- ParameterizedThreadStart, ThreadStart 
	- the second overloaded version it expects
	- The difference between new Thread(SomeMethod) and new Thread(new ThreadStart(SomeMethod)) is purely syntactical.
	- example
	static void Main(string[] args)
	{
	    Thread t2 = new Thread(Print);
	    t2.Start();			
	    Thread t = new Thread(new ThreadStart(Print));
	    t.Start();
	    //ParameterizedThreadStart pt = new ParameterizedThreadStart(Print1);
	    //Thread t1 = new Thread(pt);
	    //OR
	    Thread t1 = new Thread(new ParameterizedThreadStart(Print1));
	    t1.Start(200);
	}

	public static void Print()
	{
	    for (int i = 0; i < 100; i++) Console.WriteLine(i + " 1");
	}

	public static void Print1(Object x)
	{
	    for (int i = (int)x; i < (int)x+100; i++) Console.WriteLine(i + " 2");
	}

-----------------------------------------------------------------------------------------
Passing data to the Thread function in a type safe manner
---------------------------------------------------------
 class Program
    {
        static void Main(string[] args)
        {
            Number n = new Number();
            n.id = 25;
            Thread t1 = new Thread(n.Print);
            t1.Start();
        }
    }
    class Number
    {
        public int id { get; set; }
        public void Print()
        {
            for (int i = id; i < id + 100; i++) Console.WriteLine(i + " 2");
        }
    }

-------------------------------------------------------------------------------------------------
Retrieving data from Thread function using callback method
---------------------------------------------------------
    public delegate void DisplaySumPtr(int i);
    class Program
    {
        public static void DisplaySum(int i)
        {
            Console.WriteLine(i);
        }
        static void Main(string[] args)
        {
            DisplaySumPtr dsp = new DisplaySumPtr(DisplaySum);

            //option 1
            //Number n = new Number(25, dsp);
            //OR option 2
            Number n = new Number();
            n.id = 25;
            n.dsp = dsp;
            Thread t = new Thread(n.Print);
            t.Start();

            Console.ReadLine();
        }
    }
    class Number
    {
        public DisplaySumPtr dsp { get; set; }
        public int id { get; set; }

        //option 1
        /*public Number(int id, DisplaySumPtr dsp)
        {
            this.id = id;
            this.dsp = dsp;
        }*/

        public void Print()
        {
            int x =0;
            for (int i = id; i < id + 10; i++) x+=i;
            if (dsp!=null) dsp(x);
        }
    }
 
------------------------------------------------------------------------------------------------- 
Thead.Join and Thread.IsAlive

Join - waits for a thread to finish.
Join(milli seconds) - if thread finised with ing milli seconds true other wise false.
IsAlive - return the current thread execution status, true i still executing otherwise false

join example
------------
static void Main(string[] args)	{	|  --				| --
    Console.WriteLine("Start");		|  --				| --
    Thread t1 = new Thread(Print);	|  --				| --	
    t1.Start();				|  --				| --
    Console.WriteLine("End");		|  t1.Join();			| if(t1.Join(500)) Console.WriteLine("T1 Completed");
}					|  Console.WriteLine("End");	| else Console.WriteLine("T1 Still Running");		
									  Console.WriteLine("End");  
static void Print() {			|				|
    Console.WriteLine("Print Start");	|				|
}					|				| Thread.Sleep(5000);
									| Console.WriteLine("Print End"); }
										
output					   output			  output	
------					   ------			  ------	
Start					   Start			  Start
End					   Print Start			  Print Start	
Print Start				   End				  T1 Still Running	
									  End
									  Print End 	 
									  
join(milli seconds) example
---------------------------
static void Main(string[] args)						output
{									------
    Console.WriteLine("Start");						Start
    Thread t1 = new Thread(Print);					Print Start
    t1.Start();								T1 Still Running 0
    for (int i = 0; i < 15; i++)					T1 Still Running 1
    {									T1 Still Running 2
	if (t1.Join(750))						T1 Still Running 3	
	{								T1 Still Running 4
	    Console.WriteLine("T1 Completed " + i);			T1 Still Running 5	
	    break;							Project End
	}								T1 Completed	
	else								End
	{
	    Console.WriteLine("T1 Still Running " + i);
       }
    }
    Console.WriteLine("End");
}

static void Print()
{
    Console.WriteLine("Print Start");
    Thread.Sleep(5000);
    Console.WriteLine("Print End");
}


IsAlive example
---------------------------
static void Main(string[] args)						output
{									------
    Console.WriteLine("Start");						Start
    Thread t1 = new Thread(Print);					T1 Still Running 0
    t1.Start();								Print Start
    for (int i = 0; i < 15; i++)					T1 Still Running 1
    {									T1 Still Running 2
	if (t1.IsAlive))						T1 Still Running 3	
	{								T1 Still Running 4
	    Console.WriteLine("T1 Still Running " + i);			T1 Still Running 5	
	    Thread.Sleep(750);						T1 Still Running 5
	}								Project End
	else								T1 Completed	
	{								End
	    Console.WriteLine("T1 Completed " + i);
	    break
       }
    }
    Console.WriteLine("End");
}

static void Print()
{
    Console.WriteLine("Print Start");
    Thread.Sleep(5000);
    Console.WriteLine("Print End");
}


------------------------------------------------------------------------------------------------- 

Debug Therads in c# using Visual Studio
---------------------------------------
static in i =0;
static void Main(string args[]) 
{
	Thread one = new Thread(MyMethod);
	Thread two = new Thread(MyMethod);
	one.Statrt();
	two.Start();
	Console.ReadlLine();
}

static void MyMethod() 
{
	for (int i=0;i<10;i++)
	{
		i++;
		//Halts for 5 seconds
		Thread.Sleep(5000);
	}
}

//Debug point in i++;, press F5.
//not able to figure out that currently my debugger is deugging which thread? one or two
//in order figure it out, Goto DEbug->Windows -> Threads, it will open Thread window
//Yellow sign is the my current debugger is debugging
//Main Thread - when your application run, it always runs on thread, that threa is this thread - static void 
//Worker Thread - nothing but they are background thread.
//how do you figure it out which are our thread or .net run time syatem thread?
//From Location is MyMethod, you can figure it out your thread, atleast you know currently attached with your method
//Name  - <No Name> - who's what?

//Good Practice, name  your thread
//one.Name ="ONE";
//two.Name ="TWo";

//now debug again, you can see the Name will display the name of your thread.

//Naming your thread is handy and helpful


When your debugger is debugging a thread, all the other threads is also goes in the halt(debug) mode.

For example, currently my debugger is pointing "one", but donot think two debug is runing parellely.

All the worker there including static main thread also halted. 

For example, switch to two, select two and double click, you can see two click in the i++;


you like to debug to one theread, while debuggin one thread, pause other thread
Right click two - Freeze or Thaw, 
freeze - my debugger will allow only debug one thread, two will go pause mode. do step by step , two won't run to debug
thaw  to release the freeze

Specific 
right click, select "Condition.." break point
System.Threading.Thread.CurrentThread.NAme =="Two"


my debugger will halt when the thread is two.